# NeetCode Problems

Contains problems and solutions to [neetcode](https://neetcode.io/) 150 problems sheet.

<br>

#### Table of Contents

1. [Arrays & Hashing](#1-arrays--hashing)
2. [Two Pointers](#2-two-pointers)

<br>

### 1. Arrays & Hashing

|Problem|Trick|Link|
|-|-|-|
|[217-Contains Duplicate](https://leetcode.com/problems/contains-duplicate)|We want a container where search is instant, so we can go for `HashMap`, but since key & value both are same, we went for `HashSet` as it also stores unique elements. Now while adding a new element to the set check if the element already exists, if yes implies duplicate exists.|[Code](01_Arrays_and_Hashing/C01_217_Contains_Duplicate.java)|
|[242-Valid Anagram](https://leetcode.com/problems/valid-anagram)|First to be anagrams their lengths must be equal. Then we create a `count[]` of size 26 for each alphabet in english for storing count of each character in strings `s` and `t`. For each character in `s`, increment the count at the respective index and same for `t` except decrement the respective count. Finally, we should have an array where all elements are 0 only if they are valid anagrams.|[Code](01_Arrays_and_Hashing/C02_242_Valid_Anagram.java)|
|[1-Two Sum](https://leetcode.com/problems/two-sum)|We create a store (`HashMap`) of potential solutions untill we get the actual solution for which complementary exists in the hashmap, whose sum equals the `target`.|[Code](01_Arrays_and_Hashing/C03_1_Two_Sum.java)|
|[49-Group Anagrams](https://leetcode.com/problems/group-anagrams/)|For each string in strs, we will compute a `count[26]` array, and convert that count array to string. So, all those string which produce same count string implies are anagrams. And hence will group them into a list inside a hashmap.|[Code](01_Arrays_and_Hashing/C04_49_Group_Anagrams.java)|
|[347-Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/)|We create a hashmap containing the integers and their count. And then we use a max-heap (`PriorityQueue<Integer>`) to store integers in the decreasing order of their counts. Thus create an integer array of size and `poll()` k elements from the heap.|[Code](01_Arrays_and_Hashing/C05_347_Top_K_Frequent_Elements.java)|
|[271-Encode and Decode Strings](#)|We encode by placing `Character.toString((char) 257)` character between all the strings in the list as input strings contain 256 utf-8 characters, we do this using `StringBuilder`. For decoding remove this seperator using `str.split(Character.toString((char) 257), -1)`.|[Code](01_Arrays_and_Hashing/C06_271_Encode_and_Decode_Strings.java)|
|[238-Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self)|Make use of Prefix & Postfix Multiplication. For optimized solution calculate everything in the `res[]` array by only using two variables `pre` and `post`.|[Code](01_Arrays_and_Hashing/C07_238_Product_of_Array_Except_Self.java)|
|[36-Valid Sudoku](https://leetcode.com/problems/valid-sudoku/)|You'll need three array of `HashSet` - one for row, column and box. Then traverse the elements of the board one-by-one and check in respective hashset, if certain element is repeating twice - if so return false i.e. not a valid sudoku. If everything passes implies valid sudoku. For identifying hashset for the box use `int boxIndex = (i/3) * 3 + (j/3);`|[Code](01_Arrays_and_Hashing/C08_36_Valid_Sudoku.java)|
|[128-Longest Consecutive Sequence](https://leetcode.com/problems/longest-consecutive-sequence/)|**Approach 1:** **SORT** the `nums[]` array. Start from `i=1`, compare its prev element and ignore if duplicate. If not consecutive update `LCS_count` and reset `CCS_count`. Finally return `Math.max(LCS_count, CCS_count)`.<br>**Approach 2:** Store all the elements in a **HashSet**, and search if `num-1` exists - if *true* move on. If *false* - implies it may be the start of a LCS, so keep finding `(n+1)` from that point, keep incrementing `CCS_count`. After that update `LCS_count`, and reset `CCS_count` back to 1. Finally return `LCS_count`.|[Code](01_Arrays_and_Hashing/C09_128_Longest_Consecutive_Sequence.java)|

### 2. Two Pointers

|Problem|Trick|Link|
|-|-|-|
|[125-Valid Palindrome](https://leetcode.com/problems/valid-palindrome)|**Approach 1:** Remove all the non-alphanumeric characters from the original string, and then compare the original and its reverse lowercased strings.<br>**Approach 2:** Use `Two-Pointer` Approach. Left & Right pointers start from begin and end of the string. Keep incrementing their positions if the character is non-alphanumeric, if both are alphanumeric then ensure their lowercased character are same otheriwse return false immediately. Prepare for next iteration if they are equal. If the string passes the loop implies it is a valid palindrome.|[Code](02_Two_Pointers/C01_125_Valid_Palindrome.java)|
|[167-Two Sum II - Input Array Is Sorted](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted)|**Approach 1 (Brute Force):** For each element traverse the entire array which sums upto target.<br>**Approach 2:** Since the array is sorted, use binary search to check if the complementary exists.<br>**Approach 3:** Using two-pointer approach, numbers to the right of `left` are greater and numbers to the left of `right` are smaller. So, if `sum` of the two numbers is greater than the target implies we need smaller number - implies right needs to be decremented and vice-versa. Finally return `{left+1, right+1}` if numbers found, else return null.|[Code](02_Two_Pointers/C02_167_Two_Sum_II.java)|
|[15-Three Sum](https://leetcode.com/problems/3sum/)|The problem boils down to applying two sum problem for each element in the `nums[]` array. But the challenges are faced for duplicate elements, as they result in duplicate triplets in the result. To resolve **SORT** the array, and ignore the duplicate adjacent values for `i` as well as `j`. And also run the loop till `nums[i]<=0`, as for all other positive values, anyway the sum won't be equal to 0.|[Code](02_Two_Pointers/C03_15_Three_Sum.java)|
|[11-Container With Most Water](https://leetcode.com/problems/container-with-most-water/)|The max area (water contained) depends on the smaller height bar. So, using two pointer approach, find the area then update the `max_area` if needed. After that compare left/right whichever has small height, increment that pointer in its respective direction. Keep on calculating the area and update the `max_area` till `left <= right`.|[Code](02_Two_Pointers/C04_11_Container_With_Most_Water.java)|
|[42-Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/)|The main concept of this problem is that the water trapped depends on the minimum height of the surrounding surfaces. We have two pointers `left` and `right`. And two variables tracking left max height and right max height. We move the pointers whichever is less, and calculate the water trapped at each position and update the left max / right max height accordingly. `T.C = O(n)` & `S.C = O(1)`|[Code](02_Two_Pointers/C05_42_Trapping_Rain_Water.java)|