# NeetCode Problems

Contains problems and solutions to [neetcode](https://neetcode.io/) 150 problems sheet.

<br>

#### Table of Contents

1. [Arrays & Hashing](#1-arrays-hashing)
2. [Two Pointers](#2-two-pointers)
3. [Sliding Window](#3-sliding-window)
4. [Linked List](#4-linked-list)

<br>

### 1. Arrays & Hashing

|Problem|Trick|Link|
|-|-|-|
|[217-Contains Duplicate](https://leetcode.com/problems/contains-duplicate)|We want a container where search is instant, so we can go for `HashMap`, but since key & value both are same, we went for `HashSet` as it also stores unique elements. Now while adding a new element to the set check if the element already exists, if yes implies duplicate exists.|[Code](01_Arrays_and_Hashing/C01_217_Contains_Duplicate.java)|
|[242-Valid Anagram](https://leetcode.com/problems/valid-anagram)|First to be anagrams their lengths must be equal. Then we create a `count[]` of size 26 for each alphabet in english for storing count of each character in strings `s` and `t`. For each character in `s`, increment the count at the respective index and same for `t` except decrement the respective count. Finally, we should have an array where all elements are 0 only if they are valid anagrams.|[Code](01_Arrays_and_Hashing/C02_242_Valid_Anagram.java)|
|[1-Two Sum](https://leetcode.com/problems/two-sum)|We create a store (`HashMap`) of potential solutions untill we get the actual solution for which complementary exists in the hashmap, whose sum equals the `target`.|[Code](01_Arrays_and_Hashing/C03_1_Two_Sum.java)|
|[49-Group Anagrams](https://leetcode.com/problems/group-anagrams/)|For each string in strs, we will compute a `count[26]` array, and convert that count array to string. So, all those string which produce same count string implies are anagrams. And hence will group them into a list inside a hashmap.|[Code](01_Arrays_and_Hashing/C04_49_Group_Anagrams.java)|
|[347-Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/)|We create a hashmap containing the integers and their count. And then we use a max-heap (`PriorityQueue<Integer>`) to store integers in the decreasing order of their counts. Thus create an integer array of size and `poll()` k elements from the heap.|[Code](01_Arrays_and_Hashing/C05_347_Top_K_Frequent_Elements.java)|
|[271-Encode and Decode Strings](#)|We encode by placing `Character.toString((char) 257)` character between all the strings in the list as input strings contain 256 utf-8 characters, we do this using `StringBuilder`. For decoding remove this seperator using `str.split(Character.toString((char) 257), -1)`.|[Code](01_Arrays_and_Hashing/C06_271_Encode_and_Decode_Strings.java)|
|[238-Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self)|Make use of Prefix & Postfix Multiplication. For optimized solution calculate everything in the `res[]` array by only using two variables `pre` and `post`.|[Code](01_Arrays_and_Hashing/C07_238_Product_of_Array_Except_Self.java)|
|[36-Valid Sudoku](https://leetcode.com/problems/valid-sudoku/)|You'll need three array of `HashSet` - one for row, column and box. Then traverse the elements of the board one-by-one and check in respective hashset, if certain element is repeating twice - if so return false i.e. not a valid sudoku. If everything passes implies valid sudoku. For identifying hashset for the box use `int boxIndex = (i/3) * 3 + (j/3);`|[Code](01_Arrays_and_Hashing/C08_36_Valid_Sudoku.java)|
|[128-Longest Consecutive Sequence](https://leetcode.com/problems/longest-consecutive-sequence/)|**Approach 1:** **SORT** the `nums[]` array. Start from `i=1`, compare its prev element and ignore if duplicate. If not consecutive update `LCS_count` and reset `CCS_count`. Finally return `Math.max(LCS_count, CCS_count)`.<br>**Approach 2:** Store all the elements in a **HashSet**, and search if `num-1` exists - if *true* move on. If *false* - implies it may be the start of a LCS, so keep finding `(n+1)` from that point, keep incrementing `CCS_count`. After that update `LCS_count`, and reset `CCS_count` back to 1. Finally return `LCS_count`.|[Code](01_Arrays_and_Hashing/C09_128_Longest_Consecutive_Sequence.java)|

### 2. Two Pointers

|Problem|Trick|Link|
|-|-|-|
|[125-Valid Palindrome](https://leetcode.com/problems/valid-palindrome)|**Approach 1:** Remove all the non-alphanumeric characters from the original string, and then compare the original and its reverse lowercased strings.<br>**Approach 2:** Use `Two-Pointer` Approach. Left & Right pointers start from begin and end of the string. Keep incrementing their positions if the character is non-alphanumeric, if both are alphanumeric then ensure their lowercased character are same otheriwse return false immediately. Prepare for next iteration if they are equal. If the string passes the loop implies it is a valid palindrome.|[Code](02_Two_Pointers/C01_125_Valid_Palindrome.java)|
|[167-Two Sum II - Input Array Is Sorted](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted)|**Approach 1 (Brute Force):** For each element traverse the entire array which sums upto target.<br>**Approach 2:** Since the array is sorted, use binary search to check if the complementary exists.<br>**Approach 3:** Using two-pointer approach, numbers to the right of `left` are greater and numbers to the left of `right` are smaller. So, if `sum` of the two numbers is greater than the target implies we need smaller number - implies right needs to be decremented and vice-versa. Finally return `{left+1, right+1}` if numbers found, else return null.|[Code](02_Two_Pointers/C02_167_Two_Sum_II.java)|
|[15-Three Sum](https://leetcode.com/problems/3sum/)|The problem boils down to applying two sum problem for each element in the `nums[]` array. But the challenges are faced for duplicate elements, as they result in duplicate triplets in the result. To resolve **SORT** the array, and ignore the duplicate adjacent values for `i` as well as `j`. And also run the loop till `nums[i]<=0`, as for all other positive values, anyway the sum won't be equal to 0.|[Code](02_Two_Pointers/C03_15_Three_Sum.java)|
|[11-Container With Most Water](https://leetcode.com/problems/container-with-most-water/)|The max area (water contained) depends on the smaller height bar. So, using two pointer approach, find the area then update the `max_area` if needed. After that compare left/right whichever has small height, increment that pointer in its respective direction. Keep on calculating the area and update the `max_area` till `left <= right`.|[Code](02_Two_Pointers/C04_11_Container_With_Most_Water.java)|
|[42-Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/)|The main concept of this problem is that the water trapped depends on the minimum height of the surrounding surfaces. We have two pointers `left` and `right`. And two variables tracking left max height and right max height. We move the pointers whichever is less, and calculate the water trapped at each position and update the left max / right max height accordingly. `T.C = O(n)` & `S.C = O(1)`|[Code](02_Two_Pointers/C05_42_Trapping_Rain_Water.java)|

### 3. Sliding Window

|Problem|Trick|Link|
|-|-|-|
|[121-Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock)|Concept is that max profit can be calculated from the most min price, but caveat is that there can be multiple min(s), update profit only when you get a max profit.<br>**My Approach:** Need two variables to track `min` and `profit`. Set `min = prices[0]`. Update `min` only when you encounter the most minimum element of the `prices[]` and update `profit` only when you get a profit greater than the previous profit calculated so far.<br>**Sliding Window Approach:** Window is formed by the two pointers `left` & `right`. `right` will go till `prices.length - 1`. Update `left`|[Code](03_Sliding_Window/C01_121_Buy_and_Sell_Stock.java)|
|[3-Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/)|...|[Code](03_Sliding_Window/C02_3_Longest_Substring_Without_Repeating_Characters.java)|

### 4. Linked List

|Problem|Trick|Link|
|-|-|-|
|[206-Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)|For reversing we need three trackers. When you are at a particular node, you need the current node's ref, it's previous node to whom it should point now, and the next node for traversing ahead. Start normally as you would do with `prev_node = null`, `curr_node = head`, and `next_node` will be inside loop as it will update at every node.|[Code](04_Linked_List/C01_206_Reverse_Linked_List.java)|
|[21-Merge Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/)|You traverse both the list simultaneously joining the smaller nodes. And if any list is left out, after the loop connect with its head and now you have the merged sorted list. *The only trick here is that you will need a `dummy_node` to start with*. Use `curr_node` to traverse and link the smaller nodes.|[Code](04_Linked_List/C02_21_Merge_Sorted_Lists.java)|
|[141-Linked List Cycle Detection](https://leetcode.com/problems/linked-list-cycle/)|Run two pointers - `slow` and `fast` pointer. If there is a cycle `fast != null` and `fast.next != null`, these two conditions will never be true, and `slow == fast`, the moment that happens return `true`. And if there is no cycle, that is the traversing loop terminates, return `false`.|[Code](04_Linked_List/C03_141_LL_Cycle_Detection.java)|
|[143-Reorder List](https://leetcode.com/problems/reorder-list/)|Divide the LL from the mid-point (for even-length lists use the 1st node among the 2 mid nodes) and reverse the second half of the list. Then start inserting the nodes after each first half node untill any of the two lists finishes. (Since if original list had even nodes then half will have equal no. of nodes whereas for original odd-length list, the 2nd half will be small - so stop when the 2nd half finishes, no more insertions required).|[Code](04_Linked_List/C04_143_Reorder_List.java)|
|[19-Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)|**Brute Force Approach:** Removing nth node from end is euqivalent to removing `(N - n)`th node from start and for that we need to reach till `(N-n-1)`th node (NOTE: indexing begins from 0 for start of LL). <br> **Optimized Approach:** In the previous method we had to do two pass (one for finding the length of LL, and other for reaching till `prev_node` of nth node). But we can do the same thing in only one pass - Use the **offset method**. Have two pointers, move the `first` pointer n steps ahead and then move both the pointers simultaneously till the `first` pointer reaches `null`. Now `second` pointer will be pointing to the `prev_node` of the node which we want to delete.|[Code](04_Linked_List/C05_19_Remove_Nthnode_From_End.java)|
|[138-Copy List with Random Pointer](https://leetcode.com/problems/copy-list-with-random-pointer/)|Create the entire LL using old LL in order so that next pointer of each new node points to the correct location. While the new list creation, also create the `HashMap<Node, Node>` of corresponding nodes.Then for each node in og list you know its random value, assign the corresponding random value node to the nodes of the new list. (OR intially you can just create nodes and create the hashmap, even if you don't link the nodes, it will work as you are having the map. Then copy the corresponding next and random value nodes to the nodes of the new list, *simpleaf*).|[Code](04_Linked_List/C06_138_Copy_List_w_Random_Pointer.java)|